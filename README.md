# Локальная платформа — Block 0

Этот репозиторий содержит минимальный каркас ядра платформы для запуска в локальной сети.  
Файлы и папки создают самый базовый стартовый проект без бизнес-логики, модулей и сложных подсистем.  
Минимальность нужна, чтобы подтвердить запуск backend и frontend и ничего лишнего не включать.

## Обязательные переменные окружения

- `AUTH_SECRET_KEY` обязателен для запуска backend, иначе auth endpoints не работают и возможны runtime-ошибки.  
  Это важно для стабильности платформы, чтобы аутентификация не падала при старте.
- `DATABASE_URL` обязателен для запуска backend, иначе невозможно подключиться к базе данных.  
  Проверка выполняется при старте, чтобы остановить приложение сразу при некорректной конфигурации.
- Все обязательные переменные должны быть заданы явно, пустые значения считаются ошибкой.  
  Конфигурация читается только из env, поэтому скрытые значения по умолчанию не используются.

## Управление схемой БД и миграции

Схема базы данных управляется только через Alembic, приложение не создаёт таблицы при запуске.  
Перед запуском backend необходимо применить миграции вручную, используя `DATABASE_URL` из окружения:

```bash
python -m alembic -c alembic.ini upgrade head
```

Без выполненных миграций backend не запускается, потому что работает в режиме fail-fast.

## Диагностические endpoints

- `GET /health` — liveness-проверка процесса без обращения к БД. Возвращает `200` и JSON
  `{"status":"ok","environment":"..."}`.
- `GET /ready` — readiness-проверка готовности зависимостей. Делает лёгкий запрос `SELECT 1`
  и возвращает:
  - `200` и JSON `{"status":"ready"}` при доступной БД.
  - `503` и JSON `{"status":"not_ready","reason":"..."}` при недоступной БД.

## Минимальная диагностика старта

Во время запуска backend пишет короткие сообщения формата `STARTUP | ...`, чтобы было понятно,
на каком этапе находится приложение. Логи появляются только в фазе старта и включают:

- начало запуска;
- успешную проверку обязательной конфигурации;
- успешную проверку доступности БД;
- успешное завершение старта.

Если один из этапов не проходит, в логах появляется понятная причина, а приложение
останавливает запуск по принципу fail-fast.

## Event Core (BLOCK 22, Hybrid)

Backend поддерживает минимальный event core по модели `events + read aggregates`:

- `domain_events` хранит факты истории в едином формате: `id`, `type`, `entity`, `entity_id`, `payload`, `occurred_at`;
- `EventPublisher` записывает событие и синхронно вызывает backend-обработчики;
- обработчики обновляют read-агрегаты (пример: `calendar_day_summary`), а UI читает только агрегированное состояние.

Пример публикации события в будущих модулях backend:

```python
from app.events import DomainEvent, build_event_publisher

publisher = build_event_publisher()
event = DomainEvent.create(
    type="task.created",
    entity="task",
    entity_id="task-123",
    payload={"date": "2026-01-15", "title": "Новая задача"},
)
publisher.publish(db, event)
```

Важно: frontend не подписывается на события напрямую и не содержит бизнес-логику.
